# -*- coding: utf-8 -*-
#
# Copyright (c) 2010-2011, RMIT e-Research
#   (RMIT University, Australia)
# Copyright (c) 2010-2011, VeRSI Consortium
#   (Victorian eResearch Strategic Initiative, Australia)
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    *  Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    *  Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#    *  Neither the name of the VeRSI, the VeRSI Consortium members, nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

"""
flexstation.py

.. moduleauthor:: Guillaume Prevost <guillaume.prevost@rmit.edu.au>

"""
import logging

from itertools import izip_longest, imap
from struct import unpack, calcsize

from tardis.tardis_portal.models import Schema, DatafileParameterSet
from tardis.tardis_portal.models import ParameterName, DatafileParameter

from os import path

from struct import *

import binascii
import pdb
import time
from datetime import date

logger = logging.getLogger(__name__)


class Flexstationfilter(object):

    fmt_s = '=5i'
    fmt_spec = '=256i'
    size_s = calcsize(fmt_s)
    size = size_s + calcsize(fmt_spec)

    """This filter extract meta-data from file under the PDA format (proprietary format generated by SoftMax Pro)

    :param name: the short name of the schema.
    :type name: string
    :param schema: the name of the schema to load the PDA meta-data into.
    :type schema: string
    """
    def __init__(self, name, schema):
        self.name = name
        self.schema = schema

        self.paramnames = (
            {'name': 'softmax_version', 'full_name': 'SoftMax software version', 'data_type': 'string'}, # Version of the SoftMax software
            {'name': 'experiment_name', 'full_name': 'Experiment Name', 'data_type': 'string'}, # Name of the experiment
            {'name': 'analysis_notes', 'full_name': 'Analysis Notes', 'data_type': 'string'}, # Note about the experiment
            {'name': 'instrument_info', 'full_name': 'Instrument Info', 'data_type': 'string'}, # Details of the instrument used.
            {'name': 'plate_read_time', 'full_name': 'Plate Read Time', 'data_type': 'datetime'}, # Date and time the plate read was done.
            #{'name': 'section_type', 'full_name': 'Section Type', 'data_type': 'string'}, # Section Kind, either Plate or Cuvette.
            #{'name': 'export_format', 'full_name': 'Export Format', 'data_type': 'string'}, # PlateFormat or TimeFormat, set in Preferences
            {'name': 'strips', 'full_name': 'Strips Read', 'data_type': 'string'},
            {'name': 'read_type', 'full_name': 'Read Type', 'data_type': 'string'}, # Endpoint, Kinetic, Spectrum, Well Scan, or Flex
            {'name': 'data_mode', 'full_name': 'Data Mode', 'data_type': 'string'}, # For absorbance plates: Absorbance or % Transmittance. For others: Fluorescence, Luminescence, or Time Resolved Fluorescence.
            {'name': 'data_type', 'full_name': 'Data Type', 'data_type': 'string'}, # Raw or Reduced.
            {'name': 'trans1', 'full_name': 'Trans 2', 'data_type': 'string'}, # example: (H=80u,R=4, V=20u@15)
            {'name': 'trans2', 'full_name': 'Trans 1', 'data_type': 'string'}, # example (H=100u,R=4, V=20u@115)
            {'name': 'kinetic_points', 'full_name': 'Kinetic Points'}, # Reduced plates and Endpoint plates = 1 Kinetic / Spectrum plates: number of reads
            {'name': 'kinetic_flex_read_time', 'full_name': 'Kinetic/Flex Time', 'data_type': 'numeric'}, # Kinetic/Flex read time in seconds.
            {'name': 'kinetic_flex_interval', 'full_name': 'Kinetic/Flex Interval', 'data_type': 'numeric'}, # Kinetic or Flex read interval in seconds
            {'name': 'well_scan_read_pattern', 'full_name': 'Well Scan Read Pattern', 'data_type': 'string'}, # Well Scan read pattern (horizontal, vertical, X or fill)
            {'name': 'well_scan_density', 'full_name': 'Well Scan Density', 'data_type': 'string'}, # Well scan density
            #{'name': 'start_wavelength', 'full_name': 'Start Wavelength', 'data_type': 'string'}, # Spectrum start wavelength; otherwise blank field.
            #{'name': 'end_wavelength', 'full_name': 'End Wavelength', 'data_type': 'string'}, # Spectrum end wavelength; otherwise blank field.
            #{'name': 'wavelength_step', 'full_name': 'Wavelength Step', 'data_type': 'string'}, # Spectrum wavelength step; otherwise blank field.
            {'name': 'number_of_wavelengths', 'full_name': 'Number of Wavelengths', 'data_type': 'numeric'}, # Number of wavelengths in Endpoint, Kinetic, Well Scan, Flex reads; for Spectrum; blank field.
            {'name': 'read_wavelength', 'full_name': 'Read Wavelength', 'data_type': 'string'}, # For Absorbance / Luminescence; wavelengths read, separated by a space; for Spectrum; blank field; for Fluorescence: emission wavelengths; for Ex / Em sweep: blank field.
            {'name': 'number_of_wells_or_cuvette', 'full_name': 'Number of Wells or Cuvette', 'data_type': 'numeric'}, # Number of wells in a plate (24, 96, 384, etc.) or number of cuvettes read for a CuvetteSet.
            {'name': 'excitation_wavelengths', 'full_name': 'Excitation Wavelengths', 'data_type': 'numeric'}, # Excitation wavelengths, separated by spaces; For Luminescence or sweeps, this is a blank field (the emSweep excitation wavelength is in field 16).
            {'name': 'read_per_well', 'full_name': 'Read Per Well', 'data_type': 'numeric'}, # Number of times a well is read for a single reading.
            {'name': 'pmt_settings', 'full_name': 'PMT Settings', 'data_type': 'string'}, # Automatic, High, Medium, or Low
            {'name': 'pmt_settings', 'full_name': 'PMT Settings', 'data_type': 'string'}, # Reduction Formula to combine wavelengths
            #{'name': 'start_integration_settings', 'full_name': 'Start Integration Time'}, # Time to start integration for Time Resolved Fluorescence; otherwise, blank field.
            #{'name': 'end_integration_time', 'full_name': 'End Integration Time'}, # Time to end integration for Time Resolved Fluorescence; otherwise, blank field.
        )

    def __call__(self, sender, **kwargs):
        """post save callback entry point.

        :param sender: The model class.
        :param instance: The actual instance being saved.
        :param created: A boolean; True if a new record was created.
        :type created: bool
        """
        try:
            print("Running Flexstation filter...")

            instance = kwargs.get('instance') # get the file in the database
            filepath = instance.get_absolute_filepath()  # get the real location of the file
            mimetype = instance.get_mimetype() # get the file type

            # TODO: also check using magic number if there is one for PDA files
            if mimetype != 'application/octet-stream' and filepath.endswith((".pda", ".PDA")): # exit if we're not looking at a PDA file
                return None

            logger.info(filepath)
            logger.info(mimetype)

            # get or create the schema to hold these parameters
            schema = self.getSchema()

            # get or create the parameter definitions if they don't exist
            pn = self.getOrCreateParameterNames(schema, self.paramnames)

            # set the metadata (a dictionary of dictionaries)
            metadata = self.extractMetadata(filepath)

            self.saveFlexstationMetadata(instance, schema, metadata) # save this metadata to a file
        except Exception, e:
            # if anything goes wrong, log it in tardis.log and exit
            logger.info(e)
            return None

    # extracts the metadata from a PDA file (binary produced by SoftMax Pro)
    def extractMetadata(self, target):
        metadata = {}

        with open(target, 'rb') as f:

            # check the version number, abort if different from the expected one
            f.seek(3)
            pdaVersion = self.readStringUntilDelimiter(f)
            if pdaVersion != "5.42.1.0":
                return {}
            metadata['softmax_version'] = pdaVersion

            f.seek(f.tell() + 1)
            # Not in a try/except because if this fails to be read, there's no point continue the metadata extraction
            numberOfDatasets = self.readStringUntilDelimiter(f)
            f.seek(2418) # skip until the end of header

            # Experiment Name
            try:
                experimentName = self.readExperimentSection(f)
                metadata['experiment_name'] = experimentName
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to extract experiment name from PDA file.')

            # Templates Groups and Samples
            try:
                tmplGroupTitle, tmplSampleTitle = self.readTmplGroupAndSample(f)
                while tmplGroupTitle and tmplSampleTitle:
                    tmplGroupTitle, tmplSampleTitle = self.readTmplGroupAndSample(f)
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to extract Templates from PDA file.')

            # Number of Wells
            try:
                numberOfWells = self.readWells(f)
                metadata['number_of_wells_or_cuvette'] = numberOfWells
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to extract number of wells or cuvettes from PDA file.')


            # Analysis Notes
            try:
                analysisName, analysisContent = self.readAnalysisSection(f)
                metadata['analysis_notes'] = str.format("{0}: {1}", analysisName, analysisContent)
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to extract analysis notes from PDA file.')

            # Plate Section
            try:
                plateName = self.readPlateSection(f)
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to read plate section from PDA file.')

            # Plate Data
            try:
                firstReadColumn, numberOfColumns, readNumber, emValues, readDuration, \
                readInterval, exValues, trans1, trans2 = self.readPlateData(f)
                metadata['strips'] = str.format("{0}-{1}", firstReadColumn, firstReadColumn + numberOfColumns - 1)
                metadata['kinetic_points'] = readNumber
                metadata['kinetic_flex_read_time'] = readDuration
                metadata['kinetic_flex_interval'] = readInterval
                # TODO: alternate these in function of the read type
                #metadata['well_scan_read_pattern'] = ''
                #metadata['well_scan_density'] = ''
                metadata['read_wavelength'] = emValues
                metadata['excitation_wavelengths'] = exValues
                metadata['trans1'] = trans1
                metadata['trans2'] = trans2
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to extract plate data from PDA file.')


            # Plate Section
            try:
                self.readPlateDescriptor(f)
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to read plate descriptor from PDA file.')

            # Flex Sites (Actual Data)
            try:
                self.readFlexSites(f, numberOfColumns)
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to read flex sites from PDA file.')


            # Plate Body
            try:
                wavelength, wavelengthCombination, formula, unknown, instrumentInfos = self.readCalcPlateBody(f)
                metadata['wavelength_combination'] = wavelengthCombination
                metadata['instrument_info'] = instrumentInfos
            except DatafileParameterSet.DoesNotExist:
                logger.error('Failed to read flex sites from PDA file.')


            # TODO: find and extract these metadata
            #metadata['plate_read_time'] = date.today()
                # Section Kind ?  either Plate or Cuvette.
            #metadata['read_type'] = 'Endpoint, Kinetic, Spectrum, Well Scan, or Flex'
            #metadata['data_mode'] = 'For absorbance plates: Absorbance or % Transmittance. For others: Fluorescence, Luminescence, or Time Resolved Fluorescence.'
            #metadata['data_type'] = 'Raw or Reduced'
            #metadata['read_per_well'] = 6
            #metadata['pmt_settings'] = 'Automatic, High, Medium, or Low'

        return metadata

    # reads the 'ExperimentSection' structure
    # returns the experiment name, and the file after reading
    def readExperimentSection(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSExperimentSection":
            return

        experimentName = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 34)
        #structure = binascii.hexlify(f.read(1))
        #experimentName, serialnum, school, gradelevel = unpack('<10sHHb', record)

        return (experimentName, f)

    def readTmplGroupAndSample(self, f):
        fileIndexSave = f.tell()

        f.seek(f.tell() + 4) # skip a 4-bytes number
        tmplGroupTitle = self.readTmplGroup(f)
        tmplSampleTitle = self.readTmplSample(f)

        if tmplGroupTitle == None or tmplSampleTitle == None:
            f.seek(fileIndexSave)
            return None, None

        return tmplGroupTitle, tmplSampleTitle

    # reads a 'TmplGroup' structure
    # returns the template group title, and the file after reading
    def readTmplGroup(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSTmplGroup":
            return

        tmplGroupTitle = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 35)

        return (tmplGroupTitle)

    # reads a 'TmplSample' structure
    # returns the template sample title, and the file after reading
    def readTmplSample(self, f):
        f.seek(f.tell() + 4)
        structureName = self.readStructureName(f)
        if structureName != "CSTmplSample":
            return

        tmplGroupTitle = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 24)

        return (tmplGroupTitle)

    def readWells(self, f):
        numberOfWellsHex = binascii.hexlify(f.read(4))
        numberOfWells = int(numberOfWellsHex, 16)

        i = 0;
        while i < numberOfWells:
            wellName, rowNumber, columnNumber, plateNumber = self.readWell(f)
            i += 1

        return numberOfWells

    def readWell(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSWell":
            return

        wellName = self.readStringUntilDelimiter(f)
        hex = binascii.hexlify(f.read(2))
        rowNumber = int(hex, 16)
        hex = binascii.hexlify(f.read(2))
        columnNumber = int(hex, 16)
        f.seek(f.tell() + 6) # skip 2 + 2 + 2
        plateNumber = self.readStringUntilDelimiter(f)
        f.seek(f.tell() + 4) # skip 4

        return (wellName, rowNumber, columnNumber, plateNumber)

    # reads an 'AnalysisSection' structure
    # returns the analysis section name, its content, and the file after reading
    def readAnalysisSection(self, f):
        f.seek(f.tell() + 4)

        structureName = self.readStructureName(f)
        if structureName != "CSAnalysisSection":
            return

        analysisName = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 28) # skip 28 bytes

        analysisContent = self.readStringWithLengthPrefix(f, 4)

        f.seek(f.tell() + 58)
        return (analysisName, analysisContent)

    def readPlateSection(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSPlateSection":
            return

        plateName = self.readStringUntilDelimiter(f)
        f.seek(f.tell() + 4) # skip 4

        return (plateName)

    def readPlateData(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSPlateData":
            return

        f.seek(f.tell() + 6)

        firstReadColumnHex = binascii.hexlify(f.read(2))
        firstReadColumn = int(firstReadColumnHex, 16)
        numberOfColumnsHex = binascii.hexlify(f.read(2))
        numberOfColumns = int(numberOfColumnsHex, 16)

        readNumberHex = binascii.hexlify(f.read(4))
        readNumber = int(readNumberHex, 16)

        wavelengthsNumberHex = binascii.hexlify(f.read(4))
        wavelengthsNumber = int(wavelengthsNumberHex, 16)

        emWaveValue1Hex = binascii.hexlify(f.read(4))
        emWaveValue1 = int(emWaveValue1Hex, 16)
        f.seek(f.tell() + 1)
        emWaveValue2Hex = binascii.hexlify(f.read(4))
        emWaveValue2 = int(emWaveValue2Hex, 16)
        f.seek(f.tell() + 1)
        emValues = str.format("{0} {1}", emWaveValue1, emWaveValue2)

        f.seek(f.tell() + 4)

        readDurationHex = binascii.hexlify(f.read(8))
        readDuration = unpack('!d', readDurationHex.decode('hex'))[0]

        readIntervalHex = binascii.hexlify(f.read(8))
        readInterval = unpack('!d', readIntervalHex.decode('hex'))[0]

        f.seek(f.tell() + 170)

        exWaveValue1Hex = binascii.hexlify(f.read(4))
        exWaveValue1 = int(exWaveValue1Hex, 16)
        f.seek(f.tell() + 4)
        exWaveValue2Hex = binascii.hexlify(f.read(4))
        exWaveValue2 = int(exWaveValue2Hex, 16)
        exValues = str.format("{0} {1}", exWaveValue1, exWaveValue2)

        f.seek(f.tell() + 663)

        trans1RHex = binascii.hexlify(f.read(4))
        trans1R = int(trans1RHex, 16)
        trans1AtHex = binascii.hexlify(f.read(4))
        trans1At = int(trans1AtHex, 16)
        trans1VHex = binascii.hexlify(f.read(8))
        trans1V = unpack('!d', trans1VHex.decode('hex'))[0]
        trans1HHex = binascii.hexlify(f.read(4))
        trans1H = int(trans1HHex, 16)
        trans1 = str.format("H={0}µ, R={1}, V={2}µ, @{3}", trans1H, trans1R, trans1V, trans1At)
        f.seek(f.tell() + 16)

        trans2RHex = binascii.hexlify(f.read(4))
        trans2R = int(trans2RHex, 16)
        trans2AtHex = binascii.hexlify(f.read(4))
        trans2At = int(trans2AtHex, 16)
        trans2VHex = binascii.hexlify(f.read(8))
        trans2V = unpack('!d', trans2VHex.decode('hex'))[0]
        trans2HHex = binascii.hexlify(f.read(4))
        trans2H = int(trans2HHex, 16)
        trans2 = str.format("H={0}µ, R={1}, V={2}µ, @{3}", trans2H, trans2R, trans2V, trans2At)

        f.seek(f.tell() + 91)

        return (firstReadColumn, numberOfColumns, readNumber, emValues, readDuration, readInterval, exValues, trans1, trans2)

    def readPlateDescriptor(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSPlateDescriptor":
            return

        f.seek(f.tell() + 1)
        numberOfPlatesHex = binascii.hexlify(f.read(4))
        numberOfPlates = int(numberOfPlatesHex, 16)

        i = 0;
        while i < numberOfPlates:
            f.seek(f.tell() + 4)
            temperatureHex = binascii.hexlify(f.read(4))
            temperature = unpack('!f', temperatureHex.decode('hex'))[0]
            i += 1

        f.seek(f.tell() + 27)

        return (numberOfPlates)

    def readFlexSites(self, f, numberOfColumns):
        i = 0;
        while i < (numberOfColumns * 8):
            self.readFlexSite(f)
            i += 1
        f.seek(f.tell() + 1)

    def readFlexSite(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSFlexSite":
            return

        dataChunkNumberHex = binascii.hexlify(f.read(4))
        dataChunkNumber = int(dataChunkNumberHex, 16)

        readNumberHex = binascii.hexlify(f.read(4))
        readNumber = int(readNumberHex, 16)

        idHex = binascii.hexlify(f.read(4))
        id = int(idHex, 16)

        dataChunkLengthHex = binascii.hexlify(f.read(4))
        dataChunkLength = int(dataChunkLengthHex, 16)

        i = 0
        while (i < dataChunkNumber):
            f.seek(f.tell() + dataChunkLength)
            i += 1

        return (id)

    def readCalcPlateBody(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSCalcPlateBody":
            return

        f.seek(f.tell() + 23)

        wavelength = self.readStringUntilDelimiter(f)
        wavelengthCombination = self.readStringUntilDelimiter(f)
        formula = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 175)

        unknown = self.readStringUntilDelimiter(f)
        instrumentInfos = self.readStringUntilDelimiter(f)

        return (wavelength, wavelengthCombination, formula, unknown, instrumentInfos)

    def readMorphPlateTable(self, f):
        structureName = self.readStructureName(f)
        if structureName != "CSMorphPlateTable":
            return

        f.seek(f.tell() + 77)

        return (None)

    # reads a string from binary until a delimiter is reached (default '\x00')
    # returns: the string and the file after reading
    def readStringUntilDelimiter(self, f, delimiter = "\x00"):
        result = ''
        data = f.read(1)
        while data != delimiter:
            result += str(unpack("c", data)[0])
            data = f.read(1)
        return (result)

    # reads a structure in the PDA format
    # returns: the structure name and the file after reading
    def readStructureName(self, f):
        return (self.readStringWithLengthPrefix(f, 1))


    # reads a string prefixed by its length as a n-byte number
    # returns: the string and the file after reading
    def readStringWithLengthPrefix(self, f, numberOfByteForPrefix):
        ## reads the length of the string, on n-bytes
        stringLengthHex = binascii.hexlify(f.read(numberOfByteForPrefix))
        stringLength = int(stringLengthHex, 16)

        # read the string itself
        stringContent = f.read(stringLength)

        return (stringContent)


    # save or overwrite the datafile's metadata from the database
    def saveFlexstationMetadata(self, instance, schema, metadata):
        """Save all the metadata to a Dataset_Files parameter set.
        """
        logger.info('Saving Metadata')

        parameters = self.getParameters(schema, metadata)
        if not parameters:
            return None

        try:
            ps = DatafileParameterSet.objects.get(schema=schema,
                                                  dataset_file=instance)
            return ps  # if already exists then just return it
        except DatafileParameterSet.DoesNotExist:
            ps = DatafileParameterSet(schema=schema,
                                      dataset_file=instance)
            ps.save()

        for p in parameters:
            if p.name in metadata:
                dfp = DatafileParameter(parameterset=ps,
                                        name=p)
                if p.isNumeric():
                    if metadata[p.name] != '':
                        dfp.numerical_value = metadata[p.name]
                        dfp.save()
                else:
                    dfp.string_value = metadata[p.name]
                    dfp.save()

        return ps

    # get a list of parameters for this schema (don't have to understand this)
    def getParameters(self, schema, metadata):
        """Return a list of the paramaters that will be saved.
        """
        logger.info('test1')

        param_objects = ParameterName.objects.filter(schema=schema)
        parameters = []
        for p in metadata:

            parameter = filter(lambda x: x.name == p, param_objects)

            if parameter:
                parameters.append(parameter[0])
                continue

            # detect type of parameter
            datatype = ParameterName.STRING

            # Int test
            try:
                int(metadata[p])
            except ValueError:
                pass
            except TypeError:
                pass
            else:
                datatype = ParameterName.NUMERIC

            # Float test
            try:
                float(metadata[p])
            except ValueError:
                pass
            except TypeError:
                pass
            else:
                datatype = ParameterName.NUMERIC

        return parameters

    def getSchema(self):
        """Return the schema object that the paramaterset will use.
        """
        try:
            return Schema.objects.get(namespace__exact=self.schema)
        except Schema.DoesNotExist:
            schema = Schema(namespace=self.schema, name=self.name, type=Schema.DATAFILE)
            schema.save()
            return schema

    # takes a list of paramnames (defined in the __init__ method) to get or create new
    def getOrCreateParameterNames(self, schema, paramnames):

        pn_objects = []
        for paramname in paramnames:
            param_objects = ParameterName.objects.filter(schema=schema, name=paramname['name'])

            if len(param_objects) == 0:
                pn = ParameterName(schema=schema, name=paramname['name'], full_name=paramname['full_name'],
                                   data_type=ParameterName.STRING)
                pn.save()
            else:
                pn = param_objects[0]

            pn_objects.append(pn)

        return pn_objects


def make_filter(name='', schema=''):
    if not name:
        raise ValueError("FlexstationFilter requires a name to be specified")
    if not schema:
        raise ValueError("FlexstationFilter requires a schema to be specified")
    return Flexstationfilter(name, schema)


make_filter.__doc__ = Flexstationfilter.__doc__