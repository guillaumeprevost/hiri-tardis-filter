# -*- coding: utf-8 -*-
#
# Copyright (c) 2010-2011, RMIT e-Research
#   (RMIT University, Australia)
# Copyright (c) 2010-2011, VeRSI Consortium
#   (Victorian eResearch Strategic Initiative, Australia)
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    *  Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    *  Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#    *  Neither the name of the VeRSI, the VeRSI Consortium members, nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

"""
flexstation.py

.. moduleauthor:: Guillaume Prevost <guillaume.prevost@rmit.edu.au>

"""
import logging

from itertools import izip_longest, imap
from struct import unpack

from tardis.tardis_portal.models import Schema, DatafileParameterSet
from tardis.tardis_portal.models import ParameterName, DatafileParameter

from os import path

from struct import *

import binascii
import pdb
import time
import string
from datetime import date

logger = logging.getLogger(__name__)


class FlexstationFilter(object):

    NUMBER_OF_ROWS = 8
    HEADER_END_DELIMITER = "\x48\x00\x00\x00\x48\x00\x00\x00"

    def __init__(self, name, schema):
        """This filter extract meta-data from file under the PDA format (proprietary format generated by SoftMax Pro)
        :param name: the short name of the schema.
        :type name: str
        :param schema: the name of the schema to load the PDA meta-data into.
        :type schema: str
        """
        self.name = name
        self.schema = schema

        self.paramnames = (
            {'name': 'softmax_version', 'full_name': 'SoftMax software version', 'data_type': ParameterName.STRING}, # Version of the SoftMax software
            {'name': 'experiment_name', 'full_name': 'Experiment Name', 'data_type': ParameterName.STRING}, # Name of the experiment
            {'name': 'analysis_notes', 'full_name': 'Analysis Notes', 'data_type': ParameterName.STRING}, # Note about the experiment
            {'name': 'instrument_info', 'full_name': 'Instrument Info', 'data_type': ParameterName.STRING}, # Details of the instrument used.
            {'name': 'plate_read_time', 'full_name': 'Plate Read Time', 'data_type': ParameterName.DATETIME}, # Date and time the plate read was done.
            #{'name': 'section_type', 'full_name': 'Section Type', 'data_type': ParameterName.STRING}, # Section Kind, either Plate or Cuvette.
            #{'name': 'export_format', 'full_name': 'Export Format', 'data_type': ParameterName.STRING}, # PlateFormat or TimeFormat, set in Preferences
            {'name': 'strips', 'full_name': 'Strips Read', 'data_type': ParameterName.STRING}, #
            {'name': 'read_type', 'full_name': 'Read Type', 'data_type': ParameterName.STRING}, # Endpoint, Kinetic, Spectrum, Well Scan, or Flex
            {'name': 'data_mode', 'full_name': 'Data Mode', 'data_type': ParameterName.STRING}, # For absorbance plates: Absorbance or % Transmittance. For others: Fluorescence, Luminescence, or Time Resolved Fluorescence.
            {'name': 'data_type', 'full_name': 'Data Type', 'data_type': ParameterName.STRING}, # Raw or Reduced.
            {'name': 'trans', 'full_name': 'Trans', 'data_type': ParameterName.STRING}, # example: (H=80u,R=4, V=20u@15)
            {'name': 'kinetic_points', 'full_name': 'Kinetic Points', 'data_type': ParameterName.NUMERIC}, # Reduced plates and Endpoint plates = 1 Kinetic / Spectrum plates: number of reads
            {'name': 'kinetic_flex_read_time', 'full_name': 'Kinetic/Flex Time', 'data_type': ParameterName.NUMERIC}, # Kinetic/Flex read time in seconds.
            {'name': 'kinetic_flex_interval', 'full_name': 'Kinetic/Flex Interval', 'data_type': ParameterName.NUMERIC}, # Kinetic or Flex read interval in seconds
            {'name': 'well_scan_read_pattern', 'full_name': 'Well Scan Read Pattern', 'data_type': ParameterName.STRING}, # Well Scan read pattern (horizontal, vertical, X or fill)
            {'name': 'well_scan_density', 'full_name': 'Well Scan Density', 'data_type': ParameterName.STRING}, # Well scan density
            #{'name': 'start_wavelength', 'full_name': 'Start Wavelength', 'data_type': ParameterName.STRING}, # Spectrum start wavelength; otherwise blank field.
            #{'name': 'end_wavelength', 'full_name': 'End Wavelength', 'data_type': ParameterName.STRING}, # Spectrum end wavelength; otherwise blank field.
            #{'name': 'wavelength_step', 'full_name': 'Wavelength Step', 'data_type': ParameterName.STRING}, # Spectrum wavelength step; otherwise blank field.
            {'name': 'number_of_wavelengths', 'full_name': 'Number of Wavelengths', 'data_type': ParameterName.NUMERIC}, # Number of wavelengths in Endpoint, Kinetic, Well Scan, Flex reads; for Spectrum; blank field.
            {'name': 'read_wavelength', 'full_name': 'Read Wavelength', 'data_type': ParameterName.STRING}, # For Absorbance / Luminescence; wavelengths read, separated by a space; for Spectrum; blank field; for Fluorescence: emission wavelengths; for Ex / Em sweep: blank field.
            {'name': 'number_of_wells_or_cuvette', 'full_name': 'Number of Wells or Cuvette', 'data_type': ParameterName.NUMERIC}, # Number of wells in a plate (24, 96, 384, etc.) or number of cuvettes read for a CuvetteSet.
            {'name': 'excitation_wavelengths', 'full_name': 'Excitation Wavelengths', 'data_type': ParameterName.STRING}, # Excitation wavelengths, separated by spaces; For Luminescence or sweeps, this is a blank field (the emSweep excitation wavelength is in field 16).
            {'name': 'read_per_well', 'full_name': 'Read Per Well', 'data_type': ParameterName.NUMERIC}, # Number of times a well is read for a single reading.
            {'name': 'pmt_settings', 'full_name': 'PMT Settings', 'data_type': ParameterName.STRING}, # Automatic, High, Medium, or Low
            #{'name': 'start_integration_settings', 'full_name': 'Start Integration Time'}, # Time to start integration for Time Resolved Fluorescence; otherwise, blank field.
            #{'name': 'end_integration_time', 'full_name': 'End Integration Time'}, # Time to end integration for Time Resolved Fluorescence; otherwise, blank field.
        )

    def __call__(self, sender, **kwargs):
        """Post-save callback entry point.
        :param sender: The model class.
        :param instance: The actual instance being saved.
        :param created: A boolean; True if a new record was created.
        :type created: bool
        """

        try:
            print("Running Flexstation filter...")

            instance = kwargs.get('instance') # get the file in the database
            filepath = instance.get_absolute_filepath()  # get the real location of the file
            mimetype = instance.get_mimetype() # get the file type
            logger.info(filepath)
            logger.info(mimetype)

            # exit if we're not looking at a PDA file
            if mimetype != 'application/octet-stream' and filepath.endswith((".pda", ".PDA")):
                return None

            # get or create the schema to hold these parameters
            schema = self.getSchema()

            # get or create the parameter definitions if they don't exist
            pn = self.getOrCreateParameterNames(schema, self.paramnames)

            # set the metadata (a dictionary of dictionaries)
            metadata = self.extractMetadata(filepath)

            self.saveFlexstationMetadata(instance, schema, metadata) # save this metadata to a file

        except Exception as e:
            # if anything goes wrong, log it in tardis.log and exit
            print(e)
            logger.info(e)
            return None

    def extractMetadata(self, target):
        """Extracts the metadata from a PDA file (binary produced by SoftMax Pro)
        :param target: the path of the PDA file to extract metadata from
        :type target: str
        :returns metadata: the dictionary of the extracted metadata
        :type metadata: dict
        """
        metadata = {}

        with open(target, 'rb') as f:

            # Checks the version number, abort if different from the expected one
            self.readStringUntilDelimiter(f)
            f.read(1)
            pdaVersion = self.readStringUntilDelimiter(f).strip()
            if not pdaVersion.startswith("5."):
                print("Unsupported PDA file version '{0}' (minimum v5). Metadata can't be extracted.".format(pdaVersion))
                return {}
            metadata['softmax_version'] = pdaVersion

            f.seek(f.tell() + 1)
            numberOfDatasets = self.readStringUntilDelimiter(f)
            numberOfDatasets = int(string.strip(string.split(numberOfDatasets, "=")[1], "\r "))
            # Read until the last occurence of the header's end delimiter
            fileIndexSave = f.tell()
            while self.readStringUntilStringDelimiter(f, self.HEADER_END_DELIMITER) != None:
                fileIndexSave = f.tell()
            f.seek(fileIndexSave)

            i = 0
            while (i < numberOfDatasets):
                self.readDataset(f, metadata)
                i += 1

        return metadata

    def readDataset(self, f, metadata):
        """Extracts the metadata from a PDA file (binary produced by SoftMax Pro)
        :param f: the opened PDA file to read
        :type f: file
        :param metadata: the dictionary to add metadata into
        :type metadata: dict
        :returns metadata: the dictionary of the extracted metadata
        :type metadataa: dict
        """

        # Experiment Name
        try:
            experimentName = self.readExperimentSection(f)
            if experimentName != None:
                metadata['experiment_name'] = experimentName
            else:
                raise error
        except:
            print('Failed to extract experiment name from PDA file.')
            logger.error('Failed to extract experiment name from PDA file.')

        fileIndexSave = f.tell()
        while (1 == 1):
            f.seek(f.tell() + 4) # skip a 4-bytes number
            tmplGroupTitle = self.readTmplGroup(f)
            if (tmplGroupTitle != None):
                fileIndexSave = f.tell()
            else:
                f.seek(fileIndexSave)
                f.seek(f.tell() + 4) # skip a 4-bytes number
                tmplSampleTitle = self.readTmplSample(f)
                if (tmplSampleTitle != None):
                    fileIndexSave = f.tell()
                else:
                    f.seek(fileIndexSave)
                    numberHex = binascii.hexlify(f.read(4))
                    number = int(numberHex, 16)
                    if (number != 0):
                        f.seek(fileIndexSave)
                    if ('analysis_notes' not in metadata):
                        f.seek(f.tell() + 4) # skips 4 bytes on the 1st occurence of an analysis section
                    analysisName, analysisContent = self.readAnalysisSection(f)
                    if (analysisName == None or analysisContent == None):
                        f.seek(fileIndexSave)
                        break
                    elif analysisContent:
                        fileIndexSave = f.tell()
                        if ('analysis_notes' in metadata):
                            metadata['analysis_notes'] = str.format("{0}. {1}: {2}", metadata['analysis_notes'], \
                                                                    analysisName, analysisContent)
                        else:
                            metadata['analysis_notes'] = str.format("{0}: {1}", analysisName, analysisContent)

        # Number of Wells
        try:
            fileIndexSave = f.tell()
            numberOfWells = self.readWells(f)
            if (numberOfWells):
                metadata['number_of_wells_or_cuvette'] = numberOfWells
        except:
            f.seek(fileIndexSave)
            print('Failed to extract number of wells or cuvettes from PDA file.')
            logger.error('Failed to extract number of wells or cuvettes from PDA file.')

        fileIndexSave = f.tell()
        while (1 == 1):
            self.skipIfNumber(f, [0, 1, 2])
            tmplGroupTitle = self.readTmplGroup(f)
            if (tmplGroupTitle != None):
                fileIndexSave = f.tell()
            else:
                f.seek(fileIndexSave)
                self.skipIfNumber(f, [0, 1, 2])
                tmplSampleTitle = self.readTmplSample(f)
                if (tmplSampleTitle != None):
                    fileIndexSave = f.tell()
                else:
                    f.seek(fileIndexSave)
                    self.skipIfNumber(f, [0, 2])
                    #if ('analysis_notes' not in metadata):
                        #f.seek(f.tell() + 4) # skips 8 bytes on the 1st occurence of an analysis section
                    analysisName, analysisContent = self.readAnalysisSection(f)
                    if (analysisName == None or analysisContent == None):
                        f.seek(fileIndexSave)
                        break
                    fileIndexSave = f.tell()
                    if analysisContent:
                        if ('analysis_notes' in metadata):
                            metadata['analysis_notes'] = str.format("{0}. {1}: {2}", metadata['analysis_notes'], \
                                                                    analysisName, analysisContent)
                        else:
                            metadata['analysis_notes'] = str.format("{0}: {1}", analysisName, analysisContent)

        # Plate Section
        try:
            self.skipIfNumber(f, [0])
            self.skipIfNumber(f, [6])
            fileIndexSave = f.tell()
            plateName = self.readPlateSection(f)
            if (plateName == None):
                raise error
        except:
            f.seek(fileIndexSave)
            print('Failed to read plate section from PDA file.')
            logger.error('Failed to read plate section from PDA file.')

        # Plate Data
        numberOfColumns = 0
        try:
            fileIndexSave = f.tell()
            firstReadColumn, numberOfColumns, readNumber, wavelengthsNumber, emValues, readDuration, readInterval, exValues, trans = self.readPlateData(f)
            if numberOfColumns > 1:
                metadata['strips'] = str.format("{0}-{1}", firstReadColumn, firstReadColumn + numberOfColumns - 1)
            else:
                metadata['strips'] = str.format("{0}", firstReadColumn)
            if (wavelengthsNumber):
                metadata['number_of_wavelengths'] = wavelengthsNumber
            if (readNumber):
                metadata['kinetic_points'] = readNumber
            if (readDuration):
                metadata['kinetic_flex_read_time'] = readDuration
            if (readInterval):
                metadata['kinetic_flex_interval'] = readInterval
            # TODO: alternate these in function of the read type
            #metadata['well_scan_read_pattern'] = ''
            #metadata['well_scan_density'] = ''
            if (emValues):
                metadata['read_wavelength'] = emValues
            if (exValues):
                metadata['excitation_wavelengths'] = exValues
            if (trans):
                metadata['trans'] = trans
        except:
            f.seek(fileIndexSave)
            print('Failed to extract plate data from PDA file.')
            logger.error('Failed to extract plate data from PDA file.')

        # Plate Descriptor
        try:
            fileIndexSave = f.tell()
            numberOfPlates = self.readPlateDescriptor(f)
            if (numberOfPlates == None):
                raise error
        except:
            f.seek(fileIndexSave)
            print('Failed to read plate descriptor from PDA file.')
            logger.error('Failed to read plate descriptor from PDA file.')

        # Flex Sites (Actual Data)
        try:
            fileIndexSave = f.tell()
            numberOfFlexSites = self.readFlexSites(f, numberOfColumns)
            if (numberOfFlexSites == None or numberOfFlexSites == 0):
                raise error
        except:
            f.seek(fileIndexSave)
            print('Failed to read flex sites from PDA file.')
            logger.error('Failed to read flex sites from PDA file.')

        # Plate Body
        try:
            fileIndexSave = f.tell()
            wavelength, wavelengthCombination, formula, unknown, instrumentInfos = self.readCalcPlateBody(f)
            if (wavelengthCombination):
               metadata['wavelength_combination'] = wavelengthCombination
               if (instrumentInfos):
                   metadata['instrument_info'] = instrumentInfos
        except:
            f.seek(fileIndexSave)
            print('Failed to read plate body from PDA file.')
            logger.error('Failed to read plate body from PDA file.')


        # TODO: find and extract these metadata
        #metadata['plate_read_time'] = date.today()
            # Section Kind ?  either Plate or Cuvette.
        #metadata['read_type'] = 'Endpoint, Kinetic, Spectrum, Well Scan, or Flex'
        #metadata['data_mode'] = 'For absorbance plates: Absorbance or % Transmittance. For others: Fluorescence, Luminescence, or Time Resolved Fluorescence.'
        #metadata['data_type'] = 'Raw or Reduced'
        #metadata['read_per_well'] = 6
        #metadata['pmt_settings'] = 'Automatic, High, Medium, or Low'

        return metadata

    def readExperimentSection(self, f):
        """Reads an 'ExperimentSection' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns experimentName: the name of the experiment section
        :type experimentName: str
        """
        structureName = self.readStructureName(f)
        if structureName != "CSExperimentSection":
            return

        experimentName = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 34)
        #structure = binascii.hexlify(f.read(1))
        #experimentName, serialnum, school, gradelevel = unpack('<10sHHb', record)

        return (experimentName)

    def readTmplGroup(self, f):
        """Reads a 'TmplGroup' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns tmplGroupTitle: the template group title
        :type tmplGroupTitle: str
        """
        structureName = self.readStructureName(f)
        if structureName != "CSTmplGroup":
            return

        tmplGroupTitle = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 8)
        descriptorUnit = self.readStringUntilDelimiter(f)
        f.seek(f.tell() + 4)
        descriptorTitle = self.readStringUntilDelimiter(f)
        f.seek(f.tell() + 21)

        return (tmplGroupTitle)

    def readTmplSample(self, f):
        """Reads a 'TmplSample' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns tmplSampleTitle: the template sample title
        :type tmplSampleTitle: str
        """
        structureName = self.readStructureName(f)
        if structureName != "CSTmplSample":
            return

        tmplSampleTitle = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 24)

        return (tmplSampleTitle)

    def readAnalysisSection(self, f):
        """Reads a 'AnalysisSection' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns analysisName: the name of the analysis section
        :type analysisName: str
        :returns analysisContent: the content of the analysis section
        :type analysisContent: str
        """
        structureName = self.readStructureName(f)
        if structureName != "CSAnalysisSection":
            return (None, None)

        analysisName = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 28) # skip 28 bytes

        analysisContent = self.readStringWithLengthPrefix(f, 4)

        #f.seek(f.tell() + 58)
        delimiter = ""
        i = 0
        while (i < 32):
            delimiter = delimiter + "\xFF"
            i += 1
        self.readStringUntilStringDelimiter(f, delimiter)

        return (analysisName, analysisContent)

    def readWells(self, f):
        """Reads several 'Well' structures, based on the number of wells
        :param f: the opened PDA file to read
        :type f: file
        :returns numberOfWells: the number of wells read
        :type numberOfWells: int
        """

        numberOfWellsHex = binascii.hexlify(f.read(4))
        numberOfWells = int(numberOfWellsHex, 16)
        if (numberOfWells == None):
            return (None)

        i = 0;
        while i < numberOfWells:
            wellName, rowNumber, columnNumber, plateNumber = self.readWell(f)
            i += 1

        return (numberOfWells)

    def readWell(self, f):
        """Reads a 'Well' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns wellName: the name of the well
        :type wellName: str
        :returns rowNumber: the number of the row where this well is located
        :type rowNumber: int
        :returns columnNumber: the number of the column where this well is located
        :type columnNumber: int
        :returns plateNumber: the number of the plate where this well is located
        :type plateNumber: int
        """
        structureName = self.readStructureName(f)
        if structureName != "CSWell":
            return

        wellName = self.readStringUntilDelimiter(f)
        hex = binascii.hexlify(f.read(2))
        rowNumber = int(hex, 16)
        hex = binascii.hexlify(f.read(2))
        columnNumber = int(hex, 16)
        f.seek(f.tell() + 6) # skip 2 + 2 + 2
        plateNumber = self.readStringUntilDelimiter(f)
        f.seek(f.tell() + 4) # skip 4

        return (wellName, rowNumber, columnNumber, plateNumber)

    def readPlateSection(self, f):
        """Reads a 'PlateSection' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns plateName: the name of the plate section
        :type plateName: string
        """
        structureName = self.readStructureName(f)
        if structureName != "CSPlateSection":
            return (None)

        plateName = self.readStringUntilDelimiter(f)
        f.seek(f.tell() + 4) # skip 4

        return (plateName)

    def readPlateData(self, f):
        """Reads a 'PlateData' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns firstReadColumn: the first column of wells read
        :type firstReadColumn: int
        :returns numberOfColumns: the number of columns read (counting from the first column read)
        :type numberOfColumns: int
        :returns readNumber: the number of reads
        :type readNumber: int
        :returns wavelengthsNumber: the number of wavelengths
        :type wavelengthsNumber: int
        :returns emValues: the values of the different wavelengths, separated by spaces
        :type emValues: str
        :returns readDuration: the duration of the read
        :type readDuration: int
        :returns readInterval: the interval between each read
        :type readInterval: int
        :returns exValues: the values of the excitation wavelengths, separated by spaces
        :type exValues: str
        :returns trans: the values of trans, formatted as 'H={0}µ, R={1}, V={2}µ, @{3}'
        :type trans: str
        """
        structureName = self.readStructureName(f)
        if structureName != "CSPlateData":
            return

        f.seek(f.tell() + 6)

        firstReadColumnHex = binascii.hexlify(f.read(2))
        firstReadColumn = int(firstReadColumnHex, 16)
        numberOfColumnsHex = binascii.hexlify(f.read(2))
        numberOfColumns = int(numberOfColumnsHex, 16)

        readNumberHex = binascii.hexlify(f.read(4))
        readNumber = int(readNumberHex, 16)

        wavelengthsNumberHex = binascii.hexlify(f.read(4))
        wavelengthsNumber = int(wavelengthsNumberHex, 16)

        i = 0
        emValues = None
        while (i < wavelengthsNumber):
            emWaveValueHex = binascii.hexlify(f.read(4))
            emWaveValue = int(emWaveValueHex, 16)
            f.seek(f.tell() + 1)
            if (emValues != None):
                emValues = str.format("{0} {1}", emValues, emWaveValue)
            else:
                emValues = str.format("{0}", emWaveValue)
            i += 1

        f.seek(f.tell() + 4)

        readDurationHex = binascii.hexlify(f.read(8))
        readDuration = unpack('!d', readDurationHex.decode('hex'))[0]

        readIntervalHex = binascii.hexlify(f.read(8))
        readInterval = unpack('!d', readIntervalHex.decode('hex'))[0]

        f.seek(f.tell() + 170)

        i = 0
        exValues = None
        while (i < wavelengthsNumber):
            exWaveValueHex = binascii.hexlify(f.read(4))
            exWaveValue = int(exWaveValueHex, 16)
            f.seek(f.tell() + 4)
            if (exValues != None):
                exValues = str.format("{0} {1}", exValues, exWaveValue)
            else:
                exValues = str.format("{0}", exWaveValue)
            i += 1

        f.seek(f.tell() + 659)

        i = 0
        trans = None
        while (i < wavelengthsNumber):
            transRHex = binascii.hexlify(f.read(4))
            transR = int(transRHex, 16)
            transAtHex = binascii.hexlify(f.read(4))
            transAt = int(transAtHex, 16)
            transVHex = binascii.hexlify(f.read(8))
            transV = unpack('!d', transVHex.decode('hex'))[0]
            transHHex = binascii.hexlify(f.read(4))
            transH = int(transHHex, 16)
            f.seek(f.tell() + 16)
            formattedTrans = str.format("Trans{0}: H={1}\xb5, R={2}, V={3}\xb5, \x40{4}", (i + 1), transH, transR, transV, transAt)
            if (trans != None):
                trans = str.format("{0}. {1}", trans, formattedTrans)
            else:
                trans = str.format("{0}", formattedTrans)
            i += 1

        f.seek(f.tell() + 75)

        return (firstReadColumn, numberOfColumns, readNumber, wavelengthsNumber, emValues, readDuration, readInterval, exValues, trans)

    def readPlateDescriptor(self, f):
        """Reads a 'PlateDescriptor' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns numberOfPlates: the number of plates
        :type numberOfPlates: int
        """
        structureName = self.readStructureName(f)
        if structureName != "CSPlateDescriptor":
            return (None)

        f.seek(f.tell() + 1)
        numberOfPlatesHex = binascii.hexlify(f.read(4))
        numberOfPlates = int(numberOfPlatesHex, 16)

        i = 0;
        while i < numberOfPlates:
            f.seek(f.tell() + 4)
            temperatureHex = binascii.hexlify(f.read(4))
            temperature = unpack('!f', temperatureHex.decode('hex'))[0]
            i += 1

        f.seek(f.tell() + 27)

        return (numberOfPlates)

    def readFlexSites(self, f, numberOfColumns):
        """Reads several 'FlexSite' structures, based on the number of rows and columns
        :param f: the opened PDA file to read
        :type f: file
        :param numberOfColumns: the number of columns read
        :type numberOfColumns: int
        """
        i = 0;
        while i < (numberOfColumns * self.NUMBER_OF_ROWS):
            id = self.readFlexSite(f)
            if (id == None):
                return (None)
            i += 1
        f.seek(f.tell() + 1)
        return (i)

    def readFlexSite(self, f):
        """Reads a 'FlexSite' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns id: the id of the flex site
        :type id: int
        """
        structureName = self.readStructureName(f)
        if structureName != "CSFlexSite":
            return

        dataChunkNumberHex = binascii.hexlify(f.read(4))
        dataChunkNumber = int(dataChunkNumberHex, 16)

        readNumberHex = binascii.hexlify(f.read(4))
        readNumber = int(readNumberHex, 16)

        idHex = binascii.hexlify(f.read(4))
        id = int(idHex, 16)

        dataChunkLengthHex = binascii.hexlify(f.read(4))
        dataChunkLength = int(dataChunkLengthHex, 16)
        if (dataChunkNumber == None or dataChunkLength == None):
            return (None)

        i = 0
        while (i < dataChunkNumber):
            f.seek(f.tell() + dataChunkLength)
            i += 1

        return (id)

    def readCalcPlateBody(self, f):
        """Reads a 'CalcPlateBody' structure
        :param f: the opened PDA file to read
        :type f: file
        :returns wavelength: the wavelength of the plate body
        :type wavelength: str
        :returns wavelengthCombination: the wavelength combination
        :type wavelengthCombination: str
        :returns formula: the formula used for combining wavelengths
        :type formula: str
        :returns unknown: --
        :type unknown: str
        :returns instrumentInfos: the information about the plate reader instrument
        :type instrumentInfos: str
        """
        structureName = self.readStructureName(f)
        if structureName != "CSCalcPlateBody":
            return

        f.seek(f.tell() + 23)

        wavelength = self.readStringUntilDelimiter(f)
        wavelengthCombination = self.readStringUntilDelimiter(f)
        formula = self.readStringUntilDelimiter(f)

        f.seek(f.tell() + 175)

        unknown = self.readStringUntilDelimiter(f)
        instrumentInfos = self.readStringUntilDelimiter(f)

        return (wavelength, wavelengthCombination, formula, unknown, instrumentInfos)

    def readMorphPlateTable(self, f):
        """Reads a 'MorphPlateTable' structure
        :param f: the opened PDA file to read
        :type f: file
        """
        structureName = self.readStructureName(f)
        if structureName != "CSMorphPlateTable":
            return
        f.seek(f.tell() + 77)
        return (None)

    def readStringUntilDelimiter(self, f, delimiter="\x00"):
        """Reads a string from binary until a single-character delimiter is reached
        :param f: the opened PDA file to read
        :type f: file
        :param delimiter: the delimiter which stops the reading if encountered (default '\x00')
        :type delimiter: str
        :returns result: the string that was read, without the end delimiter. None if the delimiter was never found
        :type result: str
        """
        result = ''
        data = f.read(1)
        while data != delimiter:
            result += str(unpack("c", data)[0])
            data = f.read(1)
        return (result)

    def readStringUntilStringDelimiter(self, f, delimiter="\x00"):
        """Reads a string from binary until a string delimiter is reached (accepts a multiple-characters delimiter)
        :param f: the opened PDA file to read
        :type f: file
        :param delimiter: the delimiter which stops the reading if encountered (default "\x00")
        :type delimiter: str
        :returns result: the string that was read, without the end delimiter. None if the delimiter was never found.
        :type result: str
        """
        result = ''
        data = f.read(1)
        while data:
            result += str(unpack("c", data)[0])
            if result.endswith(delimiter):
                return (result.replace(delimiter, ""))
            data = f.read(1)

        return (None) # reached the end of the file without finding the delimiter

    def readStructureName(self, f):
        """Reads a structure name in the PDA format
        :param f: the opened PDA file to read
        :type f: file
        :returns structureName: the name of the structure
        :type structureName:
        """
        structureName = self.readStringWithLengthPrefix(f, 1)
        return (structureName)

    def readStringWithLengthPrefix(self, f, numberOfByteForPrefix):
        """Reads a string prefixed by its length as a n-byte number
        :param f: the opened PDA file to read
        :type f: file
        :param numberOfByteForPrefix: the number of bytes on which the prefix is encoded
        :type numberOfByteForPrefix: int
        :returns stringContent: the string read, of length defined by the prefix
        :type stringContent: str
        """

        # reads the length of the string, on n-bytes
        stringLengthHex = binascii.hexlify(f.read(numberOfByteForPrefix))
        stringLength = int(stringLengthHex, 16)

        # reads the string itself
        stringContent = f.read(stringLength)

        return (stringContent)

    def skipIfNumber(self, f, numbers):
        """Skips a number
        :param f: the opened hexadecimal file to read
        :type f: file
        :param numbers: a dictionnary of the numbers that should be skipped
        :type numbers: dict
        """
        fileIndexSave = f.tell()

        numberHex = binascii.hexlify(f.read(4))
        number = int(numberHex, 16)
        if (number not in numbers):
            f.seek(fileIndexSave)

    def saveFlexstationMetadata(self, instance, schema, metadata):
        """Saves or overwrites the datafile's metadata to a Dataset_Files parameter set in the database.
        """
        logger.info('Saving Metadata')

        parameters = self.getParameters(schema, metadata)
        if not parameters:
            return None

        try:
            ps = DatafileParameterSet.objects.get(schema=schema,
                                                  dataset_file=instance)
            return ps  # if already exists then just return it
        except DatafileParameterSet.DoesNotExist:
            ps = DatafileParameterSet(schema=schema,
                                      dataset_file=instance)
            ps.save()

        for p in parameters:
            if p.name in metadata:
                dfp = DatafileParameter(parameterset=ps,
                                        name=p)
                if p.isNumeric():
                    if metadata[p.name] != '':
                        dfp.numerical_value = metadata[p.name]
                        dfp.save()
                else:
                    dfp.string_value = metadata[p.name].decode('cp1252')
                    dfp.save()

        return ps

    def getParameters(self, schema, metadata):
        """Get a list of parameters for this schema
        :param schema: the schema under which the meta-data will be saved
        :type schema: Schema
        :param numbers: the dictionary of meta-data to be saved
        :type numbers: dict
        :returns parameters: a list of the parameters that will be saved.
        :type parameters: dict
        """
        param_objects = ParameterName.objects.filter(schema=schema)
        parameters = []
        for p in metadata:

            parameter = filter(lambda x: x.name == p, param_objects)

            if parameter:
                parameters.append(parameter[0])
                continue

            # detect type of parameter
            datatype = ParameterName.STRING

            # Int test
            try:
                int(metadata[p])
            except ValueError:
                pass
            except TypeError:
                pass
            else:
                datatype = ParameterName.NUMERIC

            # Float test
            try:
                float(metadata[p])
            except ValueError:
                pass
            except TypeError:
                pass
            else:
                datatype = ParameterName.NUMERIC

        return parameters

    def getSchema(self):
        """Returns the schema object that the parameter set will use.
        """
        try:
            return Schema.objects.get(namespace__exact=self.schema)
        except Schema.DoesNotExist:
            schema = Schema(namespace=self.schema, name=self.name, type=Schema.DATAFILE)
            schema.save()
            return schema

    def getOrCreateParameterNames(self, schema, paramnames):
        """ Takes a list of paramnames (defined in the __init__ method) to get or create new parameter names objects
        """
        pn_objects = []
        for paramname in paramnames:
            param_objects = ParameterName.objects.filter(schema=schema, name=paramname['name'])

            if len(param_objects) == 0:
                pn = ParameterName(schema=schema, name=paramname['name'], full_name=paramname['full_name'],
                                   data_type=paramname['data_type'])
                pn.save()
            else:
                pn = param_objects[0]

            pn_objects.append(pn)

        return pn_objects


def make_filter(name='', schema=''):
    ''' Instantiate and return the FlexstationFilter class
    :param name: the name of the filter
    :param schema: the short name of the schema to use for this filter
    :return: a new instance of the FlexstationFilter class
    '''
    if not name:
        raise ValueError("FlexstationFilter requires a name to be specified")
    if not schema:
        raise ValueError("FlexstationFilter requires a schema to be specified")
    return FlexstationFilter(name, schema)


make_filter.__doc__ = FlexstationFilter.__doc__